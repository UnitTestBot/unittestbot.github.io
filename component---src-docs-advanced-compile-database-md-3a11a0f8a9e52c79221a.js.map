{"version":3,"file":"component---src-docs-advanced-compile-database-md-3a11a0f8a9e52c79221a.js","mappings":"8RAQaA,EAAe,Q,6OAC5B,IAAMC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,GACF,YACD,OAAO,QAACJ,GAAD,UAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAG5E,cACE,GAAM,oBADR,qBAGA,6WAGF,aAAGC,WAAW,IACR,KAAQ,+CADd,yBAHE,+DAOA,mBACE,cAAIA,WAAW,MAAf,kGACA,cAAIA,WAAW,MAAf,oBAAwC,aAAGA,WAAW,KAClD,KAAQ,oCAD4B,aAAxC,0JAKF,+rCAUA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,iBADZ,+7BAoCL,mBACE,cAAIA,WAAW,MAAf,oQAGA,cAAIA,WAAW,MAAf,wKAGF,4HACA,kBAAG,eAAKC,IAAI,QAAQC,IAAI,iG,oOAK5BN,EAAWO,gBAAiB","sources":["webpack://unittestbot-web/./src/docs/advanced/compile-database.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/user/Github/utbot-new-wiki/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"compile-database\"\n    }}>{`Compile database`}</h1>\n    <p>{`When C/C++ project is opened in VS Code with UTBot plugin enabled, the plugin tries to obtain information about the\nproject structure. UTBot needs this information to create sources‚Äô ASTs with clang-tooling and to rebuild the project in\nLLVM IR. LLVM has a special format, designed to store project information (i.e. compilation database) ‚Äî\n`}<a parentName=\"p\" {...{\n        \"href\": \"https://clang.llvm.org/docs/LibTooling.html\"\n      }}>{`compile_commands.json`}</a>{`. There are various ways to obtain\ncompile_commands.json:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`If a project is built with CMake, one can pass CMAKE_EXPORT_COMPILE_COMMANDS=ON option to it;`}</li>\n      <li parentName=\"ul\">{`One can run the `}<a parentName=\"li\" {...{\n          \"href\": \"https://github.com/rizsotto/Bear\"\n        }}>{`Bear tool`}</a>{`. Bear is able to create compile_commands.json by\nanalysing Makefile commands, hence, Bear can be used if make command can be applied to a project.`}</li>\n    </ul>\n    <p>{`Unfortunately, compile_commands.json only contains information about compilation of individual source files. That is not\nsufficient to determine function behaviour. Consider a function ùëì, which calls a function ùëî in its body, while ùëî is\nspecified by an external symbol. The definition of ùëî can be provided to ùëì if an artifact containing ùëì is linked with\nthe artifact containing ùëî. If there are multiple functions ùëî in the project, it is impossible to determine, which\nfunction is used by ùëì, with only compile commands. To find a solution, a new format was invented ‚Äî link_commands.json.\nIt shares the way of representing data with compile_commands.json, but holds information from project link commands. A\nlink_commands.json example can be viewed bellow. With this information, it is easy to solve the mentioned problem ‚Äî one\nhas to look up for a pair of artifacts containing ùëì and ùëî, which are linked together while the project builds. UTBot\nneeded to be able to retrieve both compile and link information from a project. The vast majority of C/C++ projects are\nbuilt with either CMake or Makefile build systems. UTBot supports both of these, using the following approach:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n  {\n    \"command\": \"/usr/bin/ar qc liblib.a CMakeFiles/lib.dir/file3.c.o\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/lib.dir/file3.c.o\"\n    ]\n  },\n  {\n    \"command\": \"clang -fuse-ld=gold CMakeFiles/exe2.dir/file4.c.o -o exe2  liblib.a\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/exe2.dir/file4.c.o\",\n      \"c-example/build/liblib.a\"\n    ]\n  },\n  {\n    \"command\": \"/usr/bin/ar qc libhelper.a CMakeFiles/helper.dir/file1.c.o\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/helper.dir/file1.c.o\"\n    ]\n  },\n  {\n    \"command\": \"clang -fuse-ld=gold CMakeFiles/exe1.dir/file2.c.o -o exe1 libhelper.a liblib.a\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/exe1.dir/file2.c.o\",\n      \"c-example/build/libhelper.a\",\n      \"c-example/build/liblib.a\"\n    ]\n  }\n]\n`}</code></pre>\n    <ol>\n      <li parentName=\"ol\">{`If a given project is a CMake project, UTBot prompts user to invoke a cmake command on it, generating Makefiles (or\noffers to automatically do it by itself). From now on, all projects can be treated as projects which are built with\nthe use of Makefiles;`}</li>\n      <li parentName=\"ol\">{`UTBot applies Bear to project Makefiles. Bear is able to create compile_commands.json, and it was patched, so it is\nable to construct link_commands.json as well.`}</li>\n    </ol>\n    <p>{`The approach scheme can be viewed on scheme bellow, with algorithm steps highlighted with blue arrows.`}</p>\n    <p><img alt=\"jsons\" src=\"https://github.com/UnitTestBot/unittestbot.github.io/raw/source/resources/images/jsons.png\" /></p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","alt","src","isMDXComponent"],"sourceRoot":""}