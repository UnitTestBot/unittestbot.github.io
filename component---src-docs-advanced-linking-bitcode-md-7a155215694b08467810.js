"use strict";(self.webpackChunkunittestbot_web=self.webpackChunkunittestbot_web||[]).push([[2897],{57799:function(e,t,i){i.r(t),i.d(t,{_frontmatter:function(){return r},default:function(){return h}});var n=i(87462),o=i(63366),s=(i(15007),i(64983)),a=i(23017),l=(i(8156),["components"]),r={};void 0!==r&&r&&r===Object(r)&&Object.isExtensible(r)&&!Object.prototype.hasOwnProperty.call(r,"__filemeta")&&Object.defineProperty(r,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/advanced/linking-bitcode.md"}});var c={_frontmatter:r},u=a.Z;function h(e){var t=e.components,i=(0,o.Z)(e,l);return(0,s.kt)(u,(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"linking-bitcode"},"Linking bitcode"),(0,s.kt)("p",null,"Let us name a C/C++ type, struct or a function definition as a code symbol. If any C/C++ code uses a symbol, for the\ncode to be compiled, linked and run, the code artifact must contain that symbol."),(0,s.kt)("p",null,"In the example, max function does not use any other symbols in the code. Thus, to symbolically execute max function and\ngenerate tests, it is sufficient for UTBot to compile the corresponding KLEE file into LLVM IR and pass the bitcode to\nsymbolic execution engine."),(0,s.kt)("p",null,"However, in real projects, functions call other functions, and the common case in C/C++ is that symbols may be defined\nin another object file, which has to be linked with the original function object file. Hence, LLVM bitcode of KLEE files\nneeds to be linked with other bitcode files, which contain needed symbols."),(0,s.kt)("p",null,"As it was mentioned, UTBot can get information about user project build structure by running Bear tool."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"c-example project",src:"https://github.com/UnitTestBot/unittestbot.github.io/raw/source/resources/images/targetExample.png"})),(0,s.kt)("p",null,"Figure above presents the c-example project which will be referenced to illustrate UTBot linking behaviour. Suppose that\nUTBot is requested to perform test generation for a function inside file3.c. Prior to linking phase, UTBot receives\ninformation about what object file file3.c compiles into (in the figure, this file is called file3.o), as well as the\ninformation about project linkage structure. Note that link_commands.json presented\nin ",(0,s.kt)("a",{parentName:"p",href:"compile-database"},"Compile database")," is exactly the json UTBot generates for c-example project. During test\ngeneration process, it is stored in a graph like the one in the figure. A C/C++ project consists of object files, static\nand dynamic libraries, and executables. Let us call a static library, a dynamic library, or an executable a project\ntarget."),(0,s.kt)("p",null,"If functions from file3.o use symbols from other object files in the project, it is needed to link file3.o with them to\nprovide complete function definitions for KLEE. UTBot tries to minimally change user code and test it as-is, so it is\ndesired to link code in the same way as it is linked in a user project. UTBot uses a reasonable assumption: If user\nproject defines project targets, which include an object file, they are likely to contain all the needed symbols for it.\nThis is not always true, but it is conceivable that at least one project target actually uses functions from an object\nfile, so it should have all the needed symbols. Under this assumption, UTBot linkage algorithm looks for a suitable\nproject target that includes the selected object file and then creates LLVM bitcode module of this target for symbolic\nexecution."),(0,s.kt)("p",null,"Linking a project target. To link a project target, UTBot first links its dependencies recursively, and then puts them\ntogether into the project target, operating in accordance with the following rules:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If currently processed project unit is an object file, it is built into LLVM IR from corresponding sources using clang\ncompiler with -emit-llvm option; if tests generation was requested for this file, then not the original file is\ncompiled, but the KLEE file for it."),(0,s.kt)("li",{parentName:"ul"},"If currently processed project unit is a static library, it is linked from LLVM bitcode files using ar tool with\n‚Äìplugin LLVMGold.so. This stage uses the ",(0,s.kt)("a",{parentName:"li",href:"https://llvm.org/docs/GoldPlugin.html"},"LLVM Gold plugin"),", as it allows archived result to be reused in another\nlink action, whereas default ar behaviour forbids that."),(0,s.kt)("li",{parentName:"ul"},"If currently processed project unit is a shared library or an executable, it is linked from its dependencies using ld\nand LLVM Gold plugin, as shared libraries also can be linked into one another.")),(0,s.kt)("p",null,"After linkage, UTBot will have a module with a KLEE entry function wrapper for the code and all symbols, which the\nproject function might call. Such a module can be passed to KLEE. Suppose that test generation is requested for\nfunctions inside file3.c. Then UTBot will traverse c-example project as presented in figure below."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"linking scheme",src:"https://github.com/UnitTestBot/unittestbot.github.io/raw/source/resources/images/linkExample.png"})),(0,s.kt)("p",null,"There are more problems that make the linking process more complex. Link process of exe1 target from c-example is\naddressed to illustrate the algorithm."),(0,s.kt)("p",null,"There might be a case in which no symbol from static library (for instance, lib.a) is used in shared library (exe1),\nwhich appears to be a selected target. This is possible, if the dependency of exe1 from lib.a is somehow mentioned in\nthe project build system, but no code from lib.a is actually used in exe1. ld plugin detects this and does not include\nthe lib.bc bitcode in the final module. Thus, the module will not have a symbol for KLEE entry wrapper, which UTBot has\nlinked into lib.bc, and, consequently, no tests will be generated as KLEE will not have a function definition to\ninterpret."),(0,s.kt)("p",null,"This can be solved by adding ‚Äìwhole-archive option to link command, which forces all the symbols to be included, even if\nthey are unused. But, if this approach is used, another problem occurs. lib.a may contain a function, which has a\ncomplete definition only when linked with exe2. Consider a function ùëì from lib.a, which uses function ùëî from file4.o.\nIf lib.a is linked with exe1, ùëì is discarded by the linker, but if its inclusion is forced by ‚Äìwhole-archive, the\nlinkage will fail because there is no symbol for ùëî both in lib.a and exe1."),(0,s.kt)("p",null,"Given that, forcing symbols into final module is not a good idea in general, and it is better to try another target; but\nif no project target uses symbols from lib.a, then this way of linking may be applied. If user project successfully\nlinks, UTBot is able to rebuild it in LLVM IR and substitute any project function with a symbolic wrapper."),(0,s.kt)("p",null,"Choosing the right project target. To sum up, for correct linking of a bitcode module UTBot needs to find a project\ntarget which uses symbols from a specific object file. There are two types of targets UTBot tries to iteratively select\nand link:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Direct parents of the object file in link project structure. Typically, they are static libraries, which contain\nneeded symbols, because ar tool, with which they are built, includes all symbols from object files;"),(0,s.kt)("li",{parentName:"ul"},'Targets, which recursively include the request file and do not have any parents in linking structure ‚Äî root project`\ntargets. UTBot considers them for linking on the grounds that if there are dependencies between source files,\nunmentioned in build system, then chances are those dependencies will not produce a problem if we build "the biggest"\nproject targets, which are most likely to be used in reality.')),(0,s.kt)("p",null,"UTBot finds mentioned targets by an object file and tries to iteratively build them into LLVM IR. When a correctly built\ntarget is found, linking process stops and the final bitcode is passed to KLEE."),(0,s.kt)("p",null,"Although UTBot tries to guess project target automatically and it works for most users, in some scenarios it is\nimpossible to guess what the user actually wants. For example, function can have multiple behaviour depending on what it\nis linked with. In this case, UTBot offers its users a possibility to manually specify the project target."))}h&&h===Object(h)&&Object.isExtensible(h)&&!Object.prototype.hasOwnProperty.call(h,"__filemeta")&&Object.defineProperty(h,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/advanced/linking-bitcode.md"}}),h.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-advanced-linking-bitcode-md-7a155215694b08467810.js.map