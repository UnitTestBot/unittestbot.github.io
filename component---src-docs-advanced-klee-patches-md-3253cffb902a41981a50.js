"use strict";(self.webpackChunkunittestbot_web=self.webpackChunkunittestbot_web||[]).push([[1724],{1225:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return l},default:function(){return p}});var a=n(87462),i=n(63366),o=(n(15007),n(64983)),r=n(23017),s=(n(8156),["components"]),l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!Object.prototype.hasOwnProperty.call(l,"__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/advanced/klee-patches.md"}});var d={_frontmatter:l},c=r.Z;function p(e){var t=e.components,n=(0,i.Z)(e,s);return(0,o.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"klee"},"KLEE"),(0,o.kt)("p",null,"UTBot uses ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/klee/klee/releases/tag/v2.2"},"KLEE"),"\nas backend for test generation. KLEE was chosen as UTBot backend because it is able to operate on almost any C/C++\ncode (translated to LLVM IR). KLEE holds its place of one of the top tools for software verification and test generation\nin ",(0,o.kt)("a",{parentName:"p",href:"https://doi.org/10.1007/s10009-020-00570-3"},"recent years"),", remains in active development and improvement stage, has\na wide community and is highly customizable for one‚Äôs needs. While the main goal of UTBot is to make tests generation\ntechniques accessible for regular developer, additional goal to improve default KLEE coverage is also persuaded. For\nthis goal, KLEE was patched and updated in various ways."),(0,o.kt)("p",null,"Expanding the supported set of LLVM IR. KLEE 2.2 support a wide set of LLVM IR, which C/C++sources compile to. However,\nthere were unsupported instructions, which were determined to be vital for UTBot, so an effort was made to support them\nin KLEE."),(0,o.kt)("h2",{id:"floating-point"},"Floating point"),(0,o.kt)("p",null,"Namely, floating-point and sanitizer instructions were supported for symbolic execution. For floating-point\ninstructions,\n",(0,o.kt)("a",{parentName:"p",href:"https://doi.org/10.1109/ASE.2017.8115670"},"KLEE-Float"),", a development, which addresses the same problem, was rebased on\nKLEE 2.2; also, a floating-point runtime library was added. For sanitizer instructions, corresponding handlers were\nadded. Those two patches are important for UTBot: symbolic execution of floating-point instructions increases code\ncoverage, while sanitizer instructions were needed as UTBot rebuilds a given project with sanitizer support to increase\nthe quality of software verification. Sanitizer introduces new branches for many corner cases (like buffer overflows)\nand tests are generated to cover these interesting cases."),(0,o.kt)("h2",{id:"lazy-initialization"},"Lazy initialization"),(0,o.kt)("p",null,"KLEE symbolically executes functions one at a time, and if the code is symbolically executed in an empty symbolic state,\nsome paths may be left unexplored because there are no objects in the heap. To overcome this obstacle, the lazy\ninitialization technique has been implemented. The memory operations\n(reading, writing, copying and freeing memory) in KLEE are implemented in the following way: to execute the memory\noperation on pointer ùëù, the engine checks for every heap location if the pointer can reference this location. For every\nsatisfiable variant, it forks the symbolic state adding into the path condition the equality of ùëù and the heap address\nunder consideration. This behaviour has been extended. Now, the engine checks if current heap locations do not cover\nevery possible variant ùëù can reference. If not, then the engine instantiates the new block of symbolic memory and forks\nthe state adding into the path condition the equality of ùëù and the concrete heap address of this fresh block."),(0,o.kt)("h2",{id:"klee-parameters"},"KLEE parameters"),(0,o.kt)("p",null,"A parameter bcov_check_interval was added to KLEE; it is designed to put timeout on symbolic execution. When KLEE\nanalyses a branch for a while and does not increase code coverage for specified amount of time, the symbolic execution\nfor such a branch is stopped."),(0,o.kt)("h2",{id:"posix-runtime"},"POSIX Runtime"),(0,o.kt)("p",null,"UTBot is able to generate tests for functions, that use I/O processing via stdin and stdout ‚Äî a way of substituting them\nwith custom data in test bodies was invented. KLEE has its POSIX runtime, which allows symbolic execution of code that\nuses I/O calls (like open() or fread()). Essentially, the runtime initializes a symbolic array for each file descriptor\nand redirects I/O calls to wrapper functions working with such variables. These wrapper functions can be treated as\nstubs for POSIX functions calls, but provided not by UTBot, but by KLEE itself. UTBot only adds variables to KLEE POSIX\nruntime, which stand for the number of bytes used in symbolic stdin, stdout and files. Consequently, UTBot will have the\ninformation on exact number of bytes used by user code in every execution path and will not pollute test bodies with\nexcessive data created by KLEE."),(0,o.kt)("h2",{id:"interactive-mode"},"Interactive mode"),(0,o.kt)("p",null,"In the previous utbot's version ",(0,o.kt)("inlineCode",{parentName:"p"},"Generate Tests For Project")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Generate Tests For Current File")," launch ",(0,o.kt)("inlineCode",{parentName:"p"},"klee")," for\nevery function in a project or a file respectively. ",(0,o.kt)("inlineCode",{parentName:"p"},"Klee")," spends significant part of time to preprocess an input file,\nwhich small changes, when we generate tests for all functions in one file. Only entrypoint changes between different\nlaunches of ",(0,o.kt)("inlineCode",{parentName:"p"},"klee"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Interactive mode")," solves this problem: now we generate tests for all functions in a file for one launch of ",(0,o.kt)("inlineCode",{parentName:"p"},"klee"),". And\nwe make several parallel processes with ",(0,o.kt)("inlineCode",{parentName:"p"},"fork()")," after ",(0,o.kt)("inlineCode",{parentName:"p"},"klee")," finishes preprocessing to work with test generation for\ndifferent functions."),(0,o.kt)("p",null,"See the difference in time:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"interactive_mode \\ number of functions in file"),(0,o.kt)("th",{parentName:"tr",align:null},"10"),(0,o.kt)("th",{parentName:"tr",align:null},"50"),(0,o.kt)("th",{parentName:"tr",align:null},"100"),(0,o.kt)("th",{parentName:"tr",align:null},"500"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"without interactive"),(0,o.kt)("td",{parentName:"tr",align:null},"14.2s"),(0,o.kt)("td",{parentName:"tr",align:null},"71.6s"),(0,o.kt)("td",{parentName:"tr",align:null},"143.9s"),(0,o.kt)("td",{parentName:"tr",align:null},"963s")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"with interactive and 1 parallel process"),(0,o.kt)("td",{parentName:"tr",align:null},"3.8s"),(0,o.kt)("td",{parentName:"tr",align:null},"14.9s"),(0,o.kt)("td",{parentName:"tr",align:null},"30.3s"),(0,o.kt)("td",{parentName:"tr",align:null},"189s")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"with interactive and 5 parallel process"),(0,o.kt)("td",{parentName:"tr",align:null},"2.2s"),(0,o.kt)("td",{parentName:"tr",align:null},"6.6s"),(0,o.kt)("td",{parentName:"tr",align:null},"12.4s"),(0,o.kt)("td",{parentName:"tr",align:null},"66.8s")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"with interactive and 10 parallel process"),(0,o.kt)("td",{parentName:"tr",align:null},"1.9s"),(0,o.kt)("td",{parentName:"tr",align:null},"5.7s"),(0,o.kt)("td",{parentName:"tr",align:null},"10.4s"),(0,o.kt)("td",{parentName:"tr",align:null},"52.3s")))))}p&&p===Object(p)&&Object.isExtensible(p)&&!Object.prototype.hasOwnProperty.call(p,"__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/advanced/klee-patches.md"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-advanced-klee-patches-md-3253cffb902a41981a50.js.map