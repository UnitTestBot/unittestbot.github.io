{
  "examples": [
    { "id": "1", "name": "Integral types", "code": "signed long long int max_long(long long a, signed long long b) {\n  if (a > b) {\n    return a;\n  }\n  return b;\n}" },
    { "id": "2", "name": "Character types", "code": "signed char some_func(char a, unsigned char b) {\n  if (b == 'z' && a > b) return a;\n  if (b != 'z') return b;\n  return '0';\n}" },
    { "id": "3", "name": "Floating-point types", "code": "float long_double_arith(long double x) {\n  x *= 2;\n  x -= 3.21;\n  x *= fabsl(x);\n  if (x == 1.0) {\n    return 1.0;\n  } else {\n    return 3.5;\n  }\n}" },
    { "id": "4", "name": "_Bool type", "code": "#include <stdbool.h>\n\nint fun_that_accept_bools(_Bool a, bool b) {\n  if (a && b) return 1;\n  if (a) return 2;\n  if (b) return 3;\n  return 4;\n}" },
    { "id": "5", "name": "Structs as parameters", "code": "struct SupportedStruct5 {\n  short b;\n  const int a;\n  char c;\n};\n\nint structWithConstFields(struct SupportedStruct5 st) {\n  if (st.a == 0) {\n    return 1;\n  }\n  return 2;\n}" },
    { "id": "6", "name": "Structs as return values", "code": "struct SupportedStruct4 {\n  char* c;\n};\n\nconst struct SupportedStruct4 structWithConstPointerReturn(int a) {\n  if (a % 2 == 0) {\n    struct SupportedStruct4 res = {.c = \"abcd\"};\n    return res;\n  }\n  struct SupportedStruct4 res = {.c = \"ABCD\"};\n  return res;\n}" },
    { "id": "7", "name": "Unions", "code": "union MainUnion {\n  union InnerUnion {\n    union InInnerUnion {\n      unsigned int u;\n      long long l;\n    };\n    char c;\n    union InInnerUnion ininner;\n    short s;\n  } inner;\n\n  int x;\n  long long y;\n};\n\nsigned char operate_with_inner_unions(union MainUnion st) {\n  if (st.x == 5 || st.y == 5 || st.inner.c == '5' ||\n    st.inner.s == 5 || st.inner.ininner.l == 5 || st.inner.ininner.u == 5) {\n    return '5';\n  }\n\n\n  if (st.x == 5 || st.y == 102 || st.inner.s == 15) {\n    return st.inner.c;\n  }\n\n  if ((long long) st.inner.ininner.u == st.inner.ininner.l) {\n    return 'e';\n  }\n  if ((long long) st.inner.ininner.u > st.inner.ininner.l) {\n    return 'g';\n  }\n\n  return 'o';\n}" },
    { "id": "8", "name": "Pointers as parameters and return types", "code": "int c_strcmp(const char* a, const char *b) {\n  for (int i = 0; ; i++) {\n    if (a[i] != b[i]) {\n      return 0;\n    } else {\n      if (a[i] == '\\0' || b[i] == '\\0') {\n        return a[i] == '\\0' && b[i] == '\\0';\n      }\n    }\n  }\n}\n\nint void_pointer_char_usage(void *x) {\n  char *a = x;\n  return c_strcmp(a, \"hello\");\n}\n\nint* five_square_numbers(int from) {\n  static int sq[5];\n\n  for (int i = 0; i < 5; i++) {\n    sq[i] = from * from;\n    from++;\n  }\n\n  return sq;\n}" },
    { "id": "9", "name": "Pointers as struct fields members", "code": "#include <stddef.h>\n\nstruct List {\n  struct List * next;\n  int val;\n};\nint list_sum(struct List *head) {\n  struct List * cur = head;\n  int res = 0;\n  while (cur != NULL) {\n    res += cur->val;\n    cur = head->next;\n  }\n  return res;\n}\nint list_sum_sign(struct List *head) {\n  int sum = list_sum(head);\n  if (sum > 0) {\n    return 1;\n  } else if (sum < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n}" },
    { "id": "10", "name": "Pointers to functions", "code": "#include <stdlib.h>\ntypedef int (*op_func)(int, int);\n\nint f_add(int a, int b) {\n  return a + b;\n}\nint f_sub(int a, int b) {\n  return a - b;\n}\nint f_mul(int a, int b) {\n  return a * b;\n}\n\nop_func return_op(char op) {\n  switch(op) {\n    case '+': return f_add;\n    case '-': return f_sub;\n    case '*': return f_mul;\n  }\n  return NULL;\n}\n\nchar* pointerParam(char* (*f)(int*), int* x) {\n  if (*x == 1) {\n    return f(x);\n  } else{\n    return f(x + 5);\n  }\n}" },
    { "id": "11", "name": "Arrays", "code": "struct Trio {\n  int a;\n  long long b;\n  short c;\n};\n\nint index_of_struct_with_equal_fields(struct Trio arr []) {\n  for (int i = 0; i < 10; i++) {\n    if (arr[i].a == arr[i].b) {\n      if (arr[i].b == arr[i].c) {\n        return i; \n      }\n    }\n  }\n\n  return -1;\n}" },
    { "id": "12", "name": "Multidimensional arrays and pointers", "code": "int some_method(int ** pointer2d) {\n  int x = 2;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 2; j++) {\n      if (pointer2d[i][j] > 0) {\n        return i * 2 + j;\n      }\n    }\n  }\n  return -1;\n}" },
    { "id": "13", "name": "Enums", "code": "enum Sign {\n  NEGATIVE,\n  ZERO,\n  POSITIVE\n};\n\n\nint enumSignToInt(enum Sign s) {\n  if (s == ZERO) {\n    return 0;\n  }\n  if (s == NEGATIVE) {\n    return -1;\n  } else {\n    return 1;\n  } \n}\n\nint enumSignPointerToInt(enum Sign *s) {\n  return enumSignToInt(*s);\n}" },
    { "id": "14", "name": "Typedef", "code": "typedef struct __typeDefStruct {\n  int a;\n} TypeDefStruct2;\n\nint sign_of_typedef_struct2(TypeDefStruct2 x) {\n  if (x.a > 0) {\n    return 1;\n  }\n\n  if (x.a < 0) {\n    return -1;\n  }\n\n  return 0;\n}" },
    { "id": "15", "name": "Static functions", "code": "static int x = 0;\n\nstatic int static_simple(int dx)\n{\n  if (x > 0)\n  {\n    return x + dx;\n  }\n  if (x < 0)\n  {\n    return -x + dx;\n  }\n  return 0;\n}" },
    { "id": "16", "name": "Qualifiers: const, volatile, restrict etc.", "code": "const char * const foo_bar(volatile int a) {\n  if (a < 0) {\n    return \"-1\";\n  } else if (a == 0) {\n    return \"0\";\n  } else {\n    return \"1\";\n  }\n}" },
    { "id": "17", "name": "Global variables", "code": "static char* global_mutable_string;\nstatic const char* global_const_string;\n\n\nchar use_global_strings() {\n  if (!global_mutable_string) {\n    return 'M';\n  }\n  if (!global_const_string) {\n    return 'C';\n  }\n  char c = global_const_string[0];\n  char res;\n  if (c >= 'a' && c <= 'z') {\n    res = 'A' + c - 'a';\n  } else {\n    res = c;\n  }\n  global_mutable_string[0] = res;\n  return res;\n}" },
    { "id": "18", "name": "Linked list", "code": "#include <stddef.h>\n\nstruct Node {\n  struct Node *next;\n};\n\nint length_of_linked_list_less_four(struct Node *head) {\n  if (head == NULL) {\n    return 0;\n  }\n  if (head->next == NULL) {\n    return 1;\n  }\n  if (head->next->next == NULL) {\n    return 2;\n  }\n  if (head->next->next->next == NULL) {\n    return 3;\n  }\n  return -1;\n}" },
    { "id": "19", "name": "Linked list: traverse", "code": "#include <stddef.h>\n\nstruct Node {\n  struct Node *next;\n  int x;\n};\n\nint sum_list(struct Node *head) {\n  int s = 0;\n  while (head != NULL) {\n    s += head->x;\n    head = head->next;\n  }\n  return s;\n}" },
    { "id": "20", "name": "Incorrect Bubble Sort", "code": "#include <stddef.h>\n\n#define SIZE 4\n\nstruct Node {\n  int x;\n  struct Node *next;\n};\n\nint len_bound(struct Node *head, int b) {\n  int len = 0;\n  while (head != NULL && b > 0) {\n    ++len;\n    --b;\n    head = head->next;\n  }\n  return head != NULL ? -1 : len;\n}\n\nint sort(struct Node *head) {\n  int n = len_bound(head, SIZE);\n  if (n == SIZE) {\n    for (int i = 0; i < n - 2; i++) {\n      struct Node *cop = head;\n      while (cop->next != NULL) {\n        if (cop->x > cop->next->x) {\n          int t = cop->x;\n          cop->x = cop->next->x;\n          cop->next->x = t;\n        }\n        cop = cop->next;\n      }\n    }\n    int fl = 1;\n    struct Node *cop = head;\n    while (cop->next != NULL) {\n      if (cop->x > cop->next->x) {\n        fl = -1;\n      }\n      cop = cop->next;\n    }\n    if (fl == 1) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  return 0;\n}" }
  ]
}