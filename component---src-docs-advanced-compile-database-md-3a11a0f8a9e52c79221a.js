"use strict";(self.webpackChunkunittestbot_web=self.webpackChunkunittestbot_web||[]).push([[5978],{19783:function(e,t,i){i.r(t),i.d(t,{_frontmatter:function(){return r},default:function(){return p}});var n=i(87462),o=i(63366),a=(i(15007),i(64983)),l=i(23017),s=(i(8156),["components"]),r={};void 0!==r&&r&&r===Object(r)&&Object.isExtensible(r)&&!Object.prototype.hasOwnProperty.call(r,"__filemeta")&&Object.defineProperty(r,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/advanced/compile-database.md"}});var c={_frontmatter:r},m=l.Z;function p(e){var t=e.components,i=(0,o.Z)(e,s);return(0,a.kt)(m,(0,n.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"compile-database"},"Compile database"),(0,a.kt)("p",null,"When C/C++ project is opened in VS Code with UTBot plugin enabled, the plugin tries to obtain information about the\nproject structure. UTBot needs this information to create sources‚Äô ASTs with clang-tooling and to rebuild the project in\nLLVM IR. LLVM has a special format, designed to store project information (i.e. compilation database) ‚Äî\n",(0,a.kt)("a",{parentName:"p",href:"https://clang.llvm.org/docs/LibTooling.html"},"compile_commands.json"),". There are various ways to obtain\ncompile_commands.json:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If a project is built with CMake, one can pass CMAKE_EXPORT_COMPILE_COMMANDS=ON option to it;"),(0,a.kt)("li",{parentName:"ul"},"One can run the ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/rizsotto/Bear"},"Bear tool"),". Bear is able to create compile_commands.json by\nanalysing Makefile commands, hence, Bear can be used if make command can be applied to a project.")),(0,a.kt)("p",null,"Unfortunately, compile_commands.json only contains information about compilation of individual source files. That is not\nsufficient to determine function behaviour. Consider a function ùëì, which calls a function ùëî in its body, while ùëî is\nspecified by an external symbol. The definition of ùëî can be provided to ùëì if an artifact containing ùëì is linked with\nthe artifact containing ùëî. If there are multiple functions ùëî in the project, it is impossible to determine, which\nfunction is used by ùëì, with only compile commands. To find a solution, a new format was invented ‚Äî link_commands.json.\nIt shares the way of representing data with compile_commands.json, but holds information from project link commands. A\nlink_commands.json example can be viewed bellow. With this information, it is easy to solve the mentioned problem ‚Äî one\nhas to look up for a pair of artifacts containing ùëì and ùëî, which are linked together while the project builds. UTBot\nneeded to be able to retrieve both compile and link information from a project. The vast majority of C/C++ projects are\nbuilt with either CMake or Makefile build systems. UTBot supports both of these, using the following approach:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "command": "/usr/bin/ar qc liblib.a CMakeFiles/lib.dir/file3.c.o",\n    "directory": "c-example/build",\n    "files": [\n      "c-example/build/CMakeFiles/lib.dir/file3.c.o"\n    ]\n  },\n  {\n    "command": "clang -fuse-ld=gold CMakeFiles/exe2.dir/file4.c.o -o exe2  liblib.a",\n    "directory": "c-example/build",\n    "files": [\n      "c-example/build/CMakeFiles/exe2.dir/file4.c.o",\n      "c-example/build/liblib.a"\n    ]\n  },\n  {\n    "command": "/usr/bin/ar qc libhelper.a CMakeFiles/helper.dir/file1.c.o",\n    "directory": "c-example/build",\n    "files": [\n      "c-example/build/CMakeFiles/helper.dir/file1.c.o"\n    ]\n  },\n  {\n    "command": "clang -fuse-ld=gold CMakeFiles/exe1.dir/file2.c.o -o exe1 libhelper.a liblib.a",\n    "directory": "c-example/build",\n    "files": [\n      "c-example/build/CMakeFiles/exe1.dir/file2.c.o",\n      "c-example/build/libhelper.a",\n      "c-example/build/liblib.a"\n    ]\n  }\n]\n')),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"If a given project is a CMake project, UTBot prompts user to invoke a cmake command on it, generating Makefiles (or\noffers to automatically do it by itself). From now on, all projects can be treated as projects which are built with\nthe use of Makefiles;"),(0,a.kt)("li",{parentName:"ol"},"UTBot applies Bear to project Makefiles. Bear is able to create compile_commands.json, and it was patched, so it is\nable to construct link_commands.json as well.")),(0,a.kt)("p",null,"The approach scheme can be viewed on scheme bellow, with algorithm steps highlighted with blue arrows."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"jsons",src:"https://github.com/UnitTestBot/unittestbot.github.io/raw/source/resources/images/jsons.png"})))}p&&p===Object(p)&&Object.isExtensible(p)&&!Object.prototype.hasOwnProperty.call(p,"__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/advanced/compile-database.md"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-advanced-compile-database-md-3a11a0f8a9e52c79221a.js.map