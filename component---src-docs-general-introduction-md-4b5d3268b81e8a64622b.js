"use strict";(self.webpackChunkunittestbot_web=self.webpackChunkunittestbot_web||[]).push([[608],{12902:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return l},default:function(){return m}});var a=n(87462),o=n(63366),r=(n(15007),n(64983)),s=n(23017),i=(n(92586),["components"]),l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/general/introduction.md"}});var c={_frontmatter:l},u=s.Z;function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("h2",{id:"what-is-unittestbot"},"What is UnitTestBot?"),(0,r.kt)("p",null,"UnitTestBot (aka UTBot) tool provides engineers with a simple way to generate unit tests and visualize coverage for projects written in C Programming Language. It is an IDE extension (the client) paired with a docker container with the server application running inside."),(0,r.kt)("p",null,"The tool uses symbolic analysis for test cases generation. It is based on the KLEE Symbolic Virtual Machine with a new advanced PDR algorithm being developed by Research Group from Saint Petersburg State University. UnitTestBot incorporates machine learning for test names and test inputs generation. Tests are generated with Google Test Framework macros and can be formatted according to the Huawei Coding Standards."),(0,r.kt)("h2",{id:"tests-generation"},"Tests Generation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"UnitTestBot")," generates test cases by code, trying to cover maximum statements and execution paths.\nWe treat source code as ",(0,r.kt)("em",{parentName:"p"},"source of truth")," assuming that behavior is correct (corresponds to initial user demand).\nGenerated tests are placed in the so-called ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"regression suite")),". Thus, we ",(0,r.kt)("em",{parentName:"p"},"fixate")," current behavior by test cases."),(0,r.kt)("p",null,"What is the purpose? You obtain ",(0,r.kt)("strong",{parentName:"p"},"full control")," of future code changes. Any code change now ",(0,r.kt)("strong",{parentName:"p"},"can't break behavior silently"),".\nIf developer changes the code, then some tests will fall on CI. Then, ther are two possible scenarios:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Initial behavior was ",(0,r.kt)("span",{style:{color:"green"}},(0,r.kt)("b",null,"correct"))," but developer ",(0,r.kt)("i",null,"broke")," it. And, as a result, generated test helped to find a bug."),(0,r.kt)("li",{parentName:"ul"},"Initial behavior was ",(0,r.kt)("span",{style:{color:"red"}},(0,r.kt)("b",null,"incorrect"))," and developer ",(0,r.kt)("i",null,"fixed")," it. Then, test must be manually updated to fixate\nnew behavior.")),(0,r.kt)("p",null,"UTBot provides dramatic code quality improvement in the long term: after tests are generated no change can break behavior without an alarm."),(0,r.kt)("h2",{id:"errors-detection"},"Errors Detection"),(0,r.kt)("p",null,"UnitTestBot is not only able to fixate an existing code, but it also helps to find real bugs in your project.  Some code fragments might be invalid, while developers don't know about it. For example, buffer overflows, assertion failures, segmentation faults, and so on. If UTBot finds an execution\npath leading to such a situation, it creates a special test case that is added to the so-called ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"error suite")),". "),(0,r.kt)("p",null,"While all tests from ",(0,r.kt)("em",{parentName:"p"},"regression suite")," are ",(0,r.kt)("em",{parentName:"p"},"green")," right after generation, tests from ",(0,r.kt)("em",{parentName:"p"},"error suite")," are ",(0,r.kt)("em",{parentName:"p"},"red")," (they fail if you run them).\nSuch tests generated by UnitTestBot are a convenient way to discover critical problems as soon as possible. After developer fixes a bug, tests can be rerun to verify the problem is gone."),(0,r.kt)("h2",{id:"code-coverage"},"Code Coverage"),(0,r.kt)("p",null,"UTBot tries to generate test cases that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"maximize ",(0,r.kt)("a",{href:"https://en.wikipedia.org/wiki/Code_coverage"},"code coverage")," (by statements and branches);"),(0,r.kt)("li",{parentName:"ul"},"minimize number of tests, i.e. if you drop any test case from generated suite, your code coverage decreases.")),(0,r.kt)("p",null,"Of course, in an ideal world we would like to test ",(0,r.kt)("strong",{parentName:"p"},"every")," execution path of the program (so-called ",(0,r.kt)("em",{parentName:"p"},"path coverage"),"), but the number of such\npaths is often infinite due to loops and recursion. UnitTestBot aims to maximize other types of coverages: ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"statement coverage")),"\nand ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"branch coverage")),", most commonly used in coverage quality assessment tools."))}m&&m===Object(m)&&Object.isExtensible(m)&&!m.hasOwnProperty("__filemeta")&&Object.defineProperty(m,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/general/introduction.md"}}),m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-general-introduction-md-4b5d3268b81e8a64622b.js.map