{"expireTime":9007200910765525000,"key":"gatsby-plugin-mdx-entire-payload-984163fe70bbdea997b297cb0eb78941-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/home/runner/work/unittestbot.github.io/unittestbot.github.io/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":140,"offset":141},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":143},"end":{"line":5,"column":29,"offset":171},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Compile database","position":{"start":{"line":8,"column":3,"offset":176},"end":{"line":8,"column":19,"offset":192},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":174},"end":{"line":8,"column":19,"offset":192},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When C/C++ project is opened in VS Code with UTBot plugin enabled, the plugin tries to obtain information about the\nproject structure. UTBot needs this information to create sources‚Äô ASTs with clang-tooling and to rebuild the project in\nLLVM IR. LLVM has a special format, designed to store project information (i.e. compilation database) ‚Äî\n","position":{"start":{"line":10,"column":1,"offset":194},"end":{"line":13,"column":1,"offset":535},"indent":[1,1,1]}},{"type":"link","title":null,"url":"https://clang.llvm.org/docs/LibTooling.html","children":[{"type":"text","value":"compile_commands.json","position":{"start":{"line":13,"column":2,"offset":536},"end":{"line":13,"column":23,"offset":557},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":535},"end":{"line":13,"column":69,"offset":603},"indent":[]}},{"type":"text","value":". There are various ways to obtain\ncompile_commands.json:","position":{"start":{"line":13,"column":69,"offset":603},"end":{"line":14,"column":23,"offset":660},"indent":[1]}}],"position":{"start":{"line":10,"column":1,"offset":194},"end":{"line":14,"column":23,"offset":660},"indent":[1,1,1,1]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"If a project is built with CMake, one can pass CMAKE_EXPORT_COMPILE_COMMANDS=ON option to it;","position":{"start":{"line":16,"column":3,"offset":664},"end":{"line":16,"column":96,"offset":757},"indent":[]}}],"position":{"start":{"line":16,"column":3,"offset":664},"end":{"line":16,"column":96,"offset":757},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":662},"end":{"line":16,"column":96,"offset":757},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"One can run the ","position":{"start":{"line":17,"column":3,"offset":760},"end":{"line":17,"column":19,"offset":776},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/rizsotto/Bear","children":[{"type":"text","value":"Bear tool","position":{"start":{"line":17,"column":20,"offset":777},"end":{"line":17,"column":29,"offset":786},"indent":[]}}],"position":{"start":{"line":17,"column":19,"offset":776},"end":{"line":17,"column":64,"offset":821},"indent":[]}},{"type":"text","value":". Bear is able to create compile_commands.json by\nanalysing Makefile commands, hence, Bear can be used if make command can be applied to a project.","position":{"start":{"line":17,"column":64,"offset":821},"end":{"line":18,"column":100,"offset":970},"indent":[3]}}],"position":{"start":{"line":17,"column":3,"offset":760},"end":{"line":18,"column":100,"offset":970},"indent":[3]}}],"position":{"start":{"line":17,"column":1,"offset":758},"end":{"line":18,"column":100,"offset":970},"indent":[1]}}],"position":{"start":{"line":16,"column":1,"offset":662},"end":{"line":18,"column":100,"offset":970},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Unfortunately, compile_commands.json only contains information about compilation of individual source files. That is not\nsufficient to determine function behaviour. Consider a function ùëì, which calls a function ùëî in its body, while ùëî is\nspecified by an external symbol. The definition of ùëî can be provided to ùëì if an artifact containing ùëì is linked with\nthe artifact containing ùëî. If there are multiple functions ùëî in the project, it is impossible to determine, which\nfunction is used by ùëì, with only compile commands. To find a solution, a new format was invented ‚Äî link_commands.json.\nIt shares the way of representing data with compile_commands.json, but holds information from project link commands. A\nlink_commands.json example can be viewed bellow. With this information, it is easy to solve the mentioned problem ‚Äî one\nhas to look up for a pair of artifacts containing ùëì and ùëî, which are linked together while the project builds. UTBot\nneeded to be able to retrieve both compile and link information from a project. The vast majority of C/C++ projects are\nbuilt with either CMake or Makefile build systems. UTBot supports both of these, using the following approach:","position":{"start":{"line":20,"column":1,"offset":972},"end":{"line":29,"column":111,"offset":2156},"indent":[1,1,1,1,1,1,1,1,1]}}],"position":{"start":{"line":20,"column":1,"offset":972},"end":{"line":29,"column":111,"offset":2156},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"code","lang":"json","meta":null,"value":"[\n  {\n    \"command\": \"/usr/bin/ar qc liblib.a CMakeFiles/lib.dir/file3.c.o\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/lib.dir/file3.c.o\"\n    ]\n  },\n  {\n    \"command\": \"clang -fuse-ld=gold CMakeFiles/exe2.dir/file4.c.o -o exe2  liblib.a\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/exe2.dir/file4.c.o\",\n      \"c-example/build/liblib.a\"\n    ]\n  },\n  {\n    \"command\": \"/usr/bin/ar qc libhelper.a CMakeFiles/helper.dir/file1.c.o\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/helper.dir/file1.c.o\"\n    ]\n  },\n  {\n    \"command\": \"clang -fuse-ld=gold CMakeFiles/exe1.dir/file2.c.o -o exe1 libhelper.a liblib.a\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/exe1.dir/file2.c.o\",\n      \"c-example/build/libhelper.a\",\n      \"c-example/build/liblib.a\"\n    ]\n  }\n]","position":{"start":{"line":31,"column":1,"offset":2158},"end":{"line":65,"column":4,"offset":3089},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"If a given project is a CMake project, UTBot prompts user to invoke a cmake command on it, generating Makefiles (or\noffers to automatically do it by itself). From now on, all projects can be treated as projects which are built with\nthe use of Makefiles;","position":{"start":{"line":67,"column":4,"offset":3094},"end":{"line":69,"column":25,"offset":3353},"indent":[4,4]}}],"position":{"start":{"line":67,"column":4,"offset":3094},"end":{"line":69,"column":25,"offset":3353},"indent":[4,4]}}],"position":{"start":{"line":67,"column":1,"offset":3091},"end":{"line":69,"column":25,"offset":3353},"indent":[1,1]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"UTBot applies Bear to project Makefiles. Bear is able to create compile_commands.json, and it was patched, so it is\nable to construct link_commands.json as well.","position":{"start":{"line":70,"column":4,"offset":3357},"end":{"line":71,"column":49,"offset":3521},"indent":[4]}}],"position":{"start":{"line":70,"column":4,"offset":3357},"end":{"line":71,"column":49,"offset":3521},"indent":[4]}}],"position":{"start":{"line":70,"column":1,"offset":3354},"end":{"line":71,"column":49,"offset":3521},"indent":[1]}}],"position":{"start":{"line":67,"column":1,"offset":3091},"end":{"line":71,"column":49,"offset":3521},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The approach scheme can be viewed on scheme bellow, with algorithm steps highlighted with blue arrows.","position":{"start":{"line":73,"column":1,"offset":3523},"end":{"line":73,"column":103,"offset":3625},"indent":[]}}],"position":{"start":{"line":73,"column":1,"offset":3523},"end":{"line":73,"column":103,"offset":3625},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"https://github.com/UnitTestBot/unittestbot.github.io/raw/source/resources/images/jsons.png","alt":"jsons","position":{"start":{"line":75,"column":1,"offset":3627},"end":{"line":75,"column":101,"offset":3727},"indent":[]}}],"position":{"start":{"line":75,"column":1,"offset":3627},"end":{"line":75,"column":101,"offset":3727},"indent":[]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":79,"column":1,"offset":3731},"end":{"line":79,"column":31,"offset":3761},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":79,"column":31,"offset":3761}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/unittestbot.github.io/unittestbot.github.io/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"compile-database\"\n    }}>{`Compile database`}</h1>\n    <p>{`When C/C++ project is opened in VS Code with UTBot plugin enabled, the plugin tries to obtain information about the\nproject structure. UTBot needs this information to create sources‚Äô ASTs with clang-tooling and to rebuild the project in\nLLVM IR. LLVM has a special format, designed to store project information (i.e. compilation database) ‚Äî\n`}<a parentName=\"p\" {...{\n        \"href\": \"https://clang.llvm.org/docs/LibTooling.html\"\n      }}>{`compile_commands.json`}</a>{`. There are various ways to obtain\ncompile_commands.json:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`If a project is built with CMake, one can pass CMAKE_EXPORT_COMPILE_COMMANDS=ON option to it;`}</li>\n      <li parentName=\"ul\">{`One can run the `}<a parentName=\"li\" {...{\n          \"href\": \"https://github.com/rizsotto/Bear\"\n        }}>{`Bear tool`}</a>{`. Bear is able to create compile_commands.json by\nanalysing Makefile commands, hence, Bear can be used if make command can be applied to a project.`}</li>\n    </ul>\n    <p>{`Unfortunately, compile_commands.json only contains information about compilation of individual source files. That is not\nsufficient to determine function behaviour. Consider a function ùëì, which calls a function ùëî in its body, while ùëî is\nspecified by an external symbol. The definition of ùëî can be provided to ùëì if an artifact containing ùëì is linked with\nthe artifact containing ùëî. If there are multiple functions ùëî in the project, it is impossible to determine, which\nfunction is used by ùëì, with only compile commands. To find a solution, a new format was invented ‚Äî link_commands.json.\nIt shares the way of representing data with compile_commands.json, but holds information from project link commands. A\nlink_commands.json example can be viewed bellow. With this information, it is easy to solve the mentioned problem ‚Äî one\nhas to look up for a pair of artifacts containing ùëì and ùëî, which are linked together while the project builds. UTBot\nneeded to be able to retrieve both compile and link information from a project. The vast majority of C/C++ projects are\nbuilt with either CMake or Makefile build systems. UTBot supports both of these, using the following approach:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`[\n  {\n    \"command\": \"/usr/bin/ar qc liblib.a CMakeFiles/lib.dir/file3.c.o\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/lib.dir/file3.c.o\"\n    ]\n  },\n  {\n    \"command\": \"clang -fuse-ld=gold CMakeFiles/exe2.dir/file4.c.o -o exe2  liblib.a\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/exe2.dir/file4.c.o\",\n      \"c-example/build/liblib.a\"\n    ]\n  },\n  {\n    \"command\": \"/usr/bin/ar qc libhelper.a CMakeFiles/helper.dir/file1.c.o\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/helper.dir/file1.c.o\"\n    ]\n  },\n  {\n    \"command\": \"clang -fuse-ld=gold CMakeFiles/exe1.dir/file2.c.o -o exe1 libhelper.a liblib.a\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/exe1.dir/file2.c.o\",\n      \"c-example/build/libhelper.a\",\n      \"c-example/build/liblib.a\"\n    ]\n  }\n]\n`}</code></pre>\n    <ol>\n      <li parentName=\"ol\">{`If a given project is a CMake project, UTBot prompts user to invoke a cmake command on it, generating Makefiles (or\noffers to automatically do it by itself). From now on, all projects can be treated as projects which are built with\nthe use of Makefiles;`}</li>\n      <li parentName=\"ol\">{`UTBot applies Bear to project Makefiles. Bear is able to create compile_commands.json, and it was patched, so it is\nable to construct link_commands.json as well.`}</li>\n    </ol>\n    <p>{`The approach scheme can be viewed on scheme bellow, with algorithm steps highlighted with blue arrows.`}</p>\n    <p><img alt=\"jsons\" src=\"https://github.com/UnitTestBot/unittestbot.github.io/raw/source/resources/images/jsons.png\" /></p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}