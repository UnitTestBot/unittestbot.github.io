{"expireTime":9007200911767383000,"key":"transformer-remark-markdown-ast-680eaa113625e09b75f535340a111e2b--","val":{"type":"root","children":[{"type":"heading","depth":1,"children":[{"type":"text","value":"Supported C++ Syntax","position":{"start":{"line":2,"column":3,"offset":3},"end":{"line":2,"column":23,"offset":23}}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":23,"offset":23}}},{"type":"paragraph","children":[{"type":"text","value":"Support of C++ language features is very limited. Here you can find test cases examples. All code snippets below were\ntaken from ","position":{"start":{"line":4,"column":1,"offset":25},"end":{"line":5,"column":12,"offset":154}}},{"type":"link","title":null,"url":"https://github.com/UnitTestBot/UTBotCpp/tree/main/integration-tests/cpp-example/","children":[{"type":"text","value":"this directory","position":{"start":{"line":5,"column":13,"offset":155},"end":{"line":5,"column":27,"offset":169}}}],"position":{"start":{"line":5,"column":12,"offset":154},"end":{"line":5,"column":110,"offset":252}}},{"type":"text","value":".","position":{"start":{"line":5,"column":110,"offset":252},"end":{"line":5,"column":111,"offset":253}}}],"position":{"start":{"line":4,"column":1,"offset":25},"end":{"line":5,"column":111,"offset":253}}},{"type":"html","value":"<!-- toc -->","position":{"start":{"line":7,"column":1,"offset":255},"end":{"line":7,"column":13,"offset":267}}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"#reference-parameters","children":[{"type":"text","value":"Reference parameters","position":{"start":{"line":9,"column":4,"offset":272},"end":{"line":9,"column":24,"offset":292}}}],"position":{"start":{"line":9,"column":3,"offset":271},"end":{"line":9,"column":48,"offset":316}}}],"position":{"start":{"line":9,"column":3,"offset":271},"end":{"line":9,"column":48,"offset":316}}}],"position":{"start":{"line":9,"column":1,"offset":269},"end":{"line":9,"column":48,"offset":316}}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"#class-as-parameters","children":[{"type":"text","value":"Class as parameters","position":{"start":{"line":10,"column":4,"offset":320},"end":{"line":10,"column":23,"offset":339}}}],"position":{"start":{"line":10,"column":3,"offset":319},"end":{"line":10,"column":46,"offset":362}}}],"position":{"start":{"line":10,"column":3,"offset":319},"end":{"line":10,"column":46,"offset":362}}}],"position":{"start":{"line":10,"column":1,"offset":317},"end":{"line":10,"column":46,"offset":362}}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"#class-as-return-values","children":[{"type":"text","value":"Class as return values","position":{"start":{"line":11,"column":4,"offset":366},"end":{"line":11,"column":26,"offset":388}}}],"position":{"start":{"line":11,"column":3,"offset":365},"end":{"line":11,"column":52,"offset":414}}}],"position":{"start":{"line":11,"column":3,"offset":365},"end":{"line":11,"column":52,"offset":414}}}],"position":{"start":{"line":11,"column":1,"offset":363},"end":{"line":11,"column":52,"offset":414}}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"#class-methods","children":[{"type":"text","value":"Class methods","position":{"start":{"line":12,"column":4,"offset":418},"end":{"line":12,"column":17,"offset":431}}}],"position":{"start":{"line":12,"column":3,"offset":417},"end":{"line":12,"column":34,"offset":448}}}],"position":{"start":{"line":12,"column":3,"offset":417},"end":{"line":12,"column":34,"offset":448}}}],"position":{"start":{"line":12,"column":1,"offset":415},"end":{"line":12,"column":34,"offset":448}}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"#operators","children":[{"type":"text","value":"Operators","position":{"start":{"line":13,"column":4,"offset":452},"end":{"line":13,"column":13,"offset":461}}}],"position":{"start":{"line":13,"column":3,"offset":451},"end":{"line":13,"column":26,"offset":474}}}],"position":{"start":{"line":13,"column":3,"offset":451},"end":{"line":13,"column":26,"offset":474}}}],"position":{"start":{"line":13,"column":1,"offset":449},"end":{"line":13,"column":26,"offset":474}}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"#private","children":[{"type":"text","value":"Private","position":{"start":{"line":14,"column":4,"offset":478},"end":{"line":14,"column":11,"offset":485}}}],"position":{"start":{"line":14,"column":3,"offset":477},"end":{"line":14,"column":22,"offset":496}}}],"position":{"start":{"line":14,"column":3,"offset":477},"end":{"line":14,"column":22,"offset":496}}}],"position":{"start":{"line":14,"column":1,"offset":475},"end":{"line":14,"column":22,"offset":496}}}],"position":{"start":{"line":9,"column":1,"offset":269},"end":{"line":14,"column":22,"offset":496}}},{"type":"html","value":"<!-- tocstop -->","position":{"start":{"line":16,"column":1,"offset":498},"end":{"line":16,"column":17,"offset":514}}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Reference parameters","position":{"start":{"line":18,"column":4,"offset":519},"end":{"line":18,"column":24,"offset":539}}}],"position":{"start":{"line":18,"column":1,"offset":516},"end":{"line":18,"column":24,"offset":539}}},{"type":"html","value":"<!---\n> `additional info`\n\n[Source code example](https://github.com/UnitTestBot/UTBotCpp/tree/main/integration-tests/c-example/lib/types/types.c#L23)\n--->\n\n```cpp\nint double_abs_lvalue_reference(int& a) {\n    if (a < 0) {\n        a *= -2;\n    }\n    return a;\n}\n\nint double_abs_const_lvalue_reference(const int& a) {\n    if (a < 0) {\n        return -2 * a;\n    }\n    return a;\n}\n```\n\n<details> \n  <summary>Tests code</summary>\n\n```cpp\nTEST(regression, double_abs_lvalue_reference_test_1)\n{\n    // Construct input\n    int a = 0;\n\n    // Expected output\n    int expected = 0;\n\n    // Trigger the function\n    int actual = double_abs_lvalue_reference(a);\n\n    // Check results\n    EXPECT_EQ(expected, actual);\n\n    // Check function parameters\n    int expected_a = 0;\n    EXPECT_EQ(expected_a, a);\n}\n\nTEST(regression, double_abs_lvalue_reference_test_2)\n{\n    // Construct input\n    int a = -1;\n\n    // Expected output\n    int expected = 2;\n\n    // Trigger the function\n    int actual = double_abs_lvalue_reference(a);\n\n    // Check results\n    EXPECT_EQ(expected, actual);\n\n    // Check function parameters\n    int expected_a = 2;\n    EXPECT_EQ(expected_a, a);\n}\n\nTEST(regression, double_abs_const_lvalue_reference_test_1)\n{\n    // Construct input\n    int a = 0;\n\n    // Expected output\n    int expected = 0;\n\n    // Trigger the function\n    int actual = double_abs_const_lvalue_reference(a);\n\n    // Check results\n    EXPECT_EQ(expected, actual);\n}\n\nTEST(regression, double_abs_const_lvalue_reference_test_2)\n{\n    // Construct input\n    int a = -1;\n\n    // Expected output\n    int expected = 2;\n\n    // Trigger the function\n    int actual = double_abs_const_lvalue_reference(a);\n\n    // Check results\n    EXPECT_EQ(expected, actual);\n}\n```\n\n</details>\n\n## Class as parameters\n\n> For class as parameter class should be construct from initializer list of class members and has default constructor\n\n```cpp\nclass Point_2d {\npublic:\n  int x;\n  int y;\n\n  Point_2d();\n  Point_2d(const int& x, const int& y);\n}\n\n\nvoid set_abs_by_ref(Point_2d& point) {\n   if (point.x < 0) {\n       point.x = -1 * point.x;\n   }\n   if (point.y < 0) {\n       point.y *= -1;\n   }\n}\n```\n\n<details> \n  <summary>Tests code</summary>\n\n```cpp\nTEST(regression, set_abs_by_ref_test_1)\n{\n    // Construct input\n    class Point_2d point = {-1, -1};\n\n    // Expected output\n    // No output variable for void function\n\n    // Trigger the function\n    set_abs_by_ref(point);\n\n    // Check results\n    // No check results for void function\n\n    // Check function parameters\n    class Point_2d expected_point = {1, 1};\n    EXPECT_EQ(expected_point.x, point.x);\n    EXPECT_EQ(expected_point.y, point.y);\n}\n\nTEST(regression, set_abs_by_ref_test_2)\n{\n    // Construct input\n    class Point_2d point = {0, -1};\n\n    // Expected output\n    // No output variable for void function\n\n    // Trigger the function\n    set_abs_by_ref(point);\n\n    // Check results\n    // No check results for void function\n\n    // Check function parameters\n    class Point_2d expected_point = {0, 1};\n    EXPECT_EQ(expected_point.x, point.x);\n    EXPECT_EQ(expected_point.y, point.y);\n}\n\nTEST(regression, set_abs_by_ref_test_3)\n{\n    // Construct input\n    class Point_2d point = {-1, 0};\n\n    // Expected output\n    // No output variable for void function\n\n    // Trigger the function\n    set_abs_by_ref(point);\n\n    // Check results\n    // No check results for void function\n\n    // Check function parameters\n    class Point_2d expected_point = {1, 0};\n    EXPECT_EQ(expected_point.x, point.x);\n    EXPECT_EQ(expected_point.y, point.y);\n}\n\nTEST(regression, set_abs_by_ref_test_4)\n{\n    // Construct input\n    class Point_2d point = {0, 0};\n\n    // Expected output\n    // No output variable for void function\n\n    // Trigger the function\n    set_abs_by_ref(point);\n\n    // Check results\n    // No check results for void function\n\n    // Check function parameters\n    class Point_2d expected_point = {0, 0};\n    EXPECT_EQ(expected_point.x, point.x);\n    EXPECT_EQ(expected_point.y, point.y);\n}\n```\n\n</details>\n\n## Class as return values\n\n```cpp\nvoid set_abs_by_ref(Point_2d& point) {\n   if (point.x < 0) {\n       point.x = -1 * point.x;\n   }\n   if (point.y < 0) {\n       point.y *= -1;\n   }\n}\n\nPoint_2d abs_point(Point_2d point) {\n    set_abs_by_ref(point);\n    return point;\n}\n```\n\n<details>\n  <summary>Tests code</summary>\n\n```cpp\nTEST(regression, abs_point_test_1)\n{\n    // Construct input\n    class Point_2d point = {-1, 0};\n\n    // Expected output\n    class Point_2d expected = {1, 0};\n\n    // Trigger the function\n    class Point_2d actual = abs_point(point);\n\n    // Check results\n    EXPECT_EQ(expected.x, actual.x);\n    EXPECT_EQ(expected.y, actual.y);\n}\n\nTEST(regression, abs_point_test_2)\n{\n    // Construct input\n    class Point_2d point = {-1, -1};\n\n    // Expected output\n    class Point_2d expected = {1, 1};\n\n    // Trigger the function\n    class Point_2d actual = abs_point(point);\n\n    // Check results\n    EXPECT_EQ(expected.x, actual.x);\n    EXPECT_EQ(expected.y, actual.y);\n}\n\nTEST(regression, abs_point_test_3)\n{\n    // Construct input\n    class Point_2d point = {0, -1};\n\n    // Expected output\n    class Point_2d expected = {0, 1};\n\n    // Trigger the function\n    class Point_2d actual = abs_point(point);\n\n    // Check results\n    EXPECT_EQ(expected.x, actual.x);\n    EXPECT_EQ(expected.y, actual.y);\n}\n```\n\n</details>\n\n## Class methods\n\n> For genetating method tests UTBot need default constructor of class\n\n```cpp\nclass Point_2d {\npublic:\n  int x;\n  int y;\n\n  Point_2d();\n  Point_2d(const int& x, const int& y);\n}\n\nint Point_2d::get_x() const {\n    return x;\n}\n```\n\n<details>\n  <summary>Tests code</summary>\n\n```cpp\nTEST(regression, Point_2d_get_x_test_1)\n{\n    Point_2d Point_2d_obj;\n\n    // Expected output\n    int expected = 0;\n\n    // Trigger the function\n    int actual = Point_2d_obj.get_x();\n\n    // Check results\n    EXPECT_EQ(expected, actual);\n}\n```\n\n</details>\n\n## Operators\n\n```cpp\nclass Point_2d {\npublic:\n  int x;\n  int y;\n\n  Point_2d();\n  Point_2d(const int& x, const int& y);\n  Point_2d operator-=(const Point_2d& rhs);\n  friend Point_2d operator-(Point_2d lhs, const Point_2d& rhs);\n}\n\nPoint_2d Point_2d::operator-=(const Point_2d& rhs) {\n   this->x -= rhs.x;\n   this->y -= rhs.y;\n   return *this;\n}\n\nPoint_2d operator-(Point_2d lhs, const Point_2d& rhs) {\n    lhs -= rhs;\n    return lhs;\n}\n```\n\n<details>\n  <summary>Tests code</summary>\n\n```cpp\nTEST(regression, Point_2d_operator_minus_equal_test_1)\n{\n    // Construct input\n    Point_2d Point_2d_obj;\n    class Point_2d rhs = {0, 0};\n\n    // Expected output\n    class Point_2d expected = {0, 0};\n\n    // Trigger the function\n    class Point_2d actual = Point_2d_obj.operator-=(rhs);\n\n    // Check results\n    EXPECT_EQ(expected.x, actual.x);\n    EXPECT_EQ(expected.y, actual.y);\n}\n\nTEST(regression, operator_minus_test_1)\n{\n    // Construct input\n    class Point_2d lhs = {0, 0};\n    class Point_2d rhs = {0, 0};\n\n    // Expected output\n    class Point_2d expected = {0, 0};\n\n    // Trigger the function\n    class Point_2d actual = operator-(lhs, rhs);\n\n    // Check results\n    EXPECT_EQ(expected.x, actual.x);\n    EXPECT_EQ(expected.y, actual.y);\n}\n```\n\n</details>\n\n## Private\n\n> For test private UTBot use [martong/access_private.git](https://github.com/martong/access_private.git)\n\n```cpp\nclass Private {\nprivate:\n    int x;\npublic:\n    Private();\n    Private(int x);\n    friend Private get_abs_value(Private p);\n};\n\nPrivate get_abs_value(Private p) {\n    if (p.x < 0) {\n        return -1 * p.x;\n    }\n    return p;\n}\n```\n\n<details>\n  <summary>Tests code</summary>\n\n```cpp\nTEST(regression, get_abs_value_test_1)\n{\n    // Construct input\n    class Private p = {-1};\n\n    // Expected output\n    class Private expected = {1};\n\n    // Trigger the function\n    class Private actual = get_abs_value(p);\n\n    // Check results\n    EXPECT_EQ(access_private::x(expected), access_private::x(actual));\n}\n\nTEST(regression, get_abs_value_test_2)\n{\n    // Construct input\n    class Private p = {0};\n\n    // Expected output\n    class Private expected = {0};\n\n    // Trigger the function\n    class Private actual = get_abs_value(p);\n\n    // Check results\n    EXPECT_EQ(access_private::x(expected), access_private::x(actual));\n}\n```\n\n</details>","position":{"start":{"line":20,"column":1,"offset":541},"end":{"line":466,"column":11,"offset":8797}}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":466,"column":11,"offset":8797}}}}