"use strict";(self.webpackChunkunittestbot_web=self.webpackChunkunittestbot_web||[]).push([[1278],{20844:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return c},default:function(){return u}});var o=n(87462),a=n(63366),i=(n(15007),n(64983)),r=n(23017),s=(n(8156),["components"]),c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!Object.prototype.hasOwnProperty.call(c,"__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/advanced/coverage.md"}});var l={_frontmatter:c},f=r.Z;function u(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)(f,(0,o.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"coverage"},"Coverage"),(0,i.kt)("p",null,"When user wants to get information about coverage achieved by UTBot tests, UTBot recompiles test files and user code\nwith coverage instrumentation, using gcov or llvm-cov, depending on the chosen compiler for running tests. This is done\nby changing environment variables that affect UTBot Makefile. UTBot collects line coverage for user project files while\nrunning tests and displays it in VSCode plugin. Major advantage of UTBot is that it shows real project coverage\ncollected while running native binaries. If one wants to use UTBot in its command line mode, it is also able to report\ncoverage and place summary files in a specified directory."))}u&&u===Object(u)&&Object.isExtensible(u)&&!Object.prototype.hasOwnProperty.call(u,"__filemeta")&&Object.defineProperty(u,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/advanced/coverage.md"}}),u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-advanced-coverage-md-0e2fa3ae8aedb7256cc5.js.map