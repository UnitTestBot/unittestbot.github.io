"use strict";(self.webpackChunkunittestbot_web=self.webpackChunkunittestbot_web||[]).push([[3948],{55452:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return l},default:function(){return d}});var a=n(87462),i=n(63366),s=(n(15007),n(64983)),r=n(23017),o=(n(8156),["components"]),l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!Object.prototype.hasOwnProperty.call(l,"__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/advanced/preparing-sources-for-klee.md"}});var c={_frontmatter:l},u=r.Z;function d(e){var t=e.components,n=(0,i.Z)(e,o);return(0,s.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"KLEE has a simple API of creating symbolic variables and adding constraints to them; it is, in fact, that simple that\nthe process of applying the API to source code can be easily automated. UTBot considers functions as structural units\nfor its process of generating tests. Firstly, when a project is passed to UTBot, it traverses project sources ASTs using\nclang-tooling and detects all function declarations. For each declaration, types and names of its parameters are\nmemorized along with its return type. Let us consider a simple function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c++"},"int max( int a , int b ) {\n    if ( a > b ) {\n        return a ;\n    } else {\n        return b ;\n    }\n}\n")),(0,s.kt)("p",null,"Treating the function as a unit for generating tests, UTBot marks its arguments and result as symbolic variables,\nforcing KLEE to calculate input parameters as well as the expected value. This is done by generating the wrapper\nklee_entry__<function_name>\nfor every function under test in so called KLEE file."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c++"},'#include "basic_functions.c"\n#include "klee/klee.h"\n#include <stdlib.h>\nint klee_entry__max (int argc, char **argv, char **envp ) {\n    int a;\n    klee_make_symbolic (&a, sizeof(a) , "a");\n    klee_prefer_cex (&a , a >= −10 & a <= 10 );\n    int b;\n    klee_make_symbolic (&b, sizeof(b) , "b");\n    klee_prefer_cex (&b , b >= −10 & b <= 10 );\n    int res;\n    klee_make_symbolic (&res, sizeof(res), "res");\n    int utbot_tmp = max_(a, b);\n    klee_assume (utbot_tmp == result);\n    return 0 ;\n}\n')),(0,s.kt)("p",null,"Let us break the wrapper down and explain its contents in detail:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},'Initial source file is included as "basic_functions.c" file; As a result of doing this, the function and its wrapper\nare provided with the same set of defined symbols, which means that UTBot can call the tested function from the\nwrapper file and with the same behaviour;'),(0,s.kt)("li",{parentName:"ul"},'"klee/klee.h" is included to provide the file with KLEE API.'),(0,s.kt)("li",{parentName:"ul"},"A KLEE entry function wrapper is created for targeted function. Inside it, the following things happen:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"Function arguments are marked as symbolic. In simplest case, this is achieved by calling klee_make_symbolic on a\nfresh variable address. If the argument type is pointer, UTBot performs a more sophisticated approach — creates a\nsymbolic buffer and then creates pointer on stack that references this buffer. If the argument is a string, UTBot\nautomatically adds \\0 symbol to the end of symbolic buffer for it to represent a C-style string."),(0,s.kt)("li",{parentName:"ul"},"Soft constraints are imposed on symbolic variables, advising KLEE to provide more human-readable test cases. Those\nconstraints are applied with a klee_prefer_cex call. Soft constraints are desirable but not necessary so KLEE can\ndiscard them if needed for a branch exploration. For symbolic arrays, soft constraint is applied for every item."),(0,s.kt)("li",{parentName:"ul"},"A symbolic variable is created for a function result. That is done in the same way as creating symbolic variables\nfor function arguments."),(0,s.kt)("li",{parentName:"ul"},"A concrete variable is created and its value is assigned to a function call result. When the file will be passed\ninto KLEE, it is this line in which the symbolic engine will branch and explore target function paths."),(0,s.kt)("li",{parentName:"ul"},"A constraint is applied to new symbolic variable, setting it equal to calculated function result. This is done\nwith klee_assume call. Since KLEE writes out all symbolic variables, UTBot forces function result to be calculated\nfor every argument set KLEE has explored. Therefore, UTBot does not need to rerun user code for received argument\nsets and already has the information about function return value.")))),(0,s.kt)("p",null,"In advanced generation scenario when UTBot generates test that run through specified line of code, UTBot modifies source\ncode of function under test (virtually, by clang tooling), adding global variable line_touched; and statement\nline_touched=1; next to the selected line of code. Change of this new global variable can be monitored by klee_assume\nsimilarly to assuming the function result value."))}d&&d===Object(d)&&Object.isExtensible(d)&&!Object.prototype.hasOwnProperty.call(d,"__filemeta")&&Object.defineProperty(d,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/advanced/preparing-sources-for-klee.md"}}),d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-advanced-preparing-sources-for-klee-md-13a0df639b73d22d758e.js.map