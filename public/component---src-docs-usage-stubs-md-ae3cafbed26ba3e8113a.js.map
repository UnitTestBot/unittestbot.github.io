{"version":3,"file":"component---src-docs-usage-stubs-md-ae3cafbed26ba3e8113a.js","mappings":"8RAQaA,EAAe,Q,yMAC5B,IAAMC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,GACF,YACD,OAAO,QAACJ,GAAD,UAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAG5E,cACE,GAAM,SADR,UAGA,4FACA,2BACE,aAAGC,WAAW,cAAd,MAAiC,kBAAQA,WAAW,KAAnB,UACjC,aAAGA,WAAW,eAAa,kBAAQA,WAAW,KAAnB,QAA3B,oLAGF,cACE,GAAM,uBADR,wBAGA,sJACA,kEAAoD,sBAAYA,WAAW,KAAvB,4CAApD,gRAGA,oBAAK,gBAAMA,WAAW,OAAjB,iGAOL,mDAAqC,sBAAYA,WAAW,KAAvB,OAArC,yBAA6G,sBAAYA,WAAW,KAAvB,UAA7G,0EAAyO,sBAAYA,WAAW,KAAvB,OAAzO,UAAkS,sBAAYA,WAAW,KAAvB,OAAlS,wBAAyW,sBAAYA,WAAW,KAAvB,OAAzW,UAAka,sBAAYA,WAAW,KAAvB,OAAla,iCAAkf,sBAAYA,WAAW,KAAvB,OAAlf,mGAAooB,sBAAYA,WAAW,KAAvB,OAApoB,wCAA2tB,sBAAYA,WAAW,KAAvB,aAA3tB,iBAAiyB,aAAGA,WAAW,IAC3yB,KAAQ,uDADqxB,YAAjyB,MAGA,cACE,GAAM,qBADR,sBAGA,gDAAkC,sBAAYA,WAAW,KAAvB,eAAlC,4DAC4C,sBAAYA,WAAW,KAAvB,uCAD5C,cACyI,aAAGA,WAAW,IACnJ,KAAQ,6FAD6H,mBADzI,MAIA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,yyBA8BL,4KACA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,8BAIL,gCAAkB,sBAAYA,WAAW,KAAvB,aAAlB,+GAAsL,sBAAYA,WAAW,KAAvB,aAAtL,gEACA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,0HAML,6EACA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,gCAIL,gPACA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,oCAIL,+CAAiC,sBAAYA,WAAW,KAAvB,aAAjC,uIACA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,wOAUL,cACE,GAAM,gBADR,iBAGA,oSAEA,2BACE,aAAGA,WAAW,cAAd,MAAiC,kBAAQA,WAAW,KAAnB,UACjC,aAAGA,WAAW,cAAd,kOAEF,cACE,GAAM,oBADR,qBAGA,oJAEA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,8xBA0CL,0BAAY,sBAAYA,WAAW,KAAvB,6BAAZ,6BAA8G,sBAAYA,WAAW,KAAvB,oBAA9G,oBACA,cACE,GAAM,mBADR,oBAGA,oLACsE,sBAAYA,WAAW,KAAvB,aADtE,6CAGA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,uhBAsBL,oHAAsG,sBAAYA,WAAW,KAAvB,gCAAtG,MACA,iaACA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,gBADZ,i2BAgCL,qCAAuB,sBAAYA,WAAW,KAAvB,oBAAvB,2L,gMAKJJ,EAAWK,gBAAiB","sources":["webpack://unittestbot-web/./src/docs/usage/stubs.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/user/unittestbot.github.io/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"stubs\"\n    }}>{`Stubs`}</h1>\n    <p>{`Here we describe how stubs are generated and what they are needed for.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`üìù`}<strong parentName=\"p\">{`Note`}</strong></p>\n      <p parentName=\"blockquote\"><strong parentName=\"p\">{`Stub`}</strong>{` is a function which emulates behavior of another function it is written for.\nIt's often useful to write stubs for functions from another module that you don't want to test.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"when-stubs-are-used\"\n    }}>{`When stubs are used`}</h3>\n    <p>{`UTBot generates stubs for every function in the project first time you open it and synchronize each time before test generation.`}</p>\n    <p>{`First time you open the project you will see `}<inlineCode parentName=\"p\">{`UTBot is generating stubs for project...`}</inlineCode>{` message.\nIt means that for each file in your project UTBot generates file which contains all non-static functions signatures from the source file.\nStubs can be used as substitutes for calling functions from another module. Consider the following project structure:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`executable\n|---- lib1.a\n|     |---- A.c\n|     +---- B.c\n|---- lib2.a\n|     |---- C.c\n`}</code></pre>\n    <p>{`If we run test generation for `}<inlineCode parentName=\"p\">{`C.c`}</inlineCode>{`, all functions from `}<inlineCode parentName=\"p\">{`lib1.a`}</inlineCode>{` will be replaced with their stubs on build step. So, if the function `}<inlineCode parentName=\"p\">{`foo`}</inlineCode>{` from `}<inlineCode parentName=\"p\">{`C.c`}</inlineCode>{` calls the function `}<inlineCode parentName=\"p\">{`bar`}</inlineCode>{` from `}<inlineCode parentName=\"p\">{`A.c`}</inlineCode>{`, then stub for the function `}<inlineCode parentName=\"p\">{`bar`}</inlineCode>{` will be invoked instead. Note that you can still generate tests using the exact definition of `}<inlineCode parentName=\"p\">{`bar`}</inlineCode>{`; for that, you will need to unmark `}<inlineCode parentName=\"p\">{`Use Stubs`}</inlineCode>{` checkbox in `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/cpp/usage/vscode-extension-settings#use-stubs\"\n      }}>{`settings`}</a>{`.`}</p>\n    <h3 {...{\n      \"id\": \"stub-file-example\"\n    }}>{`Stub file example`}</h3>\n    <p>{`Stub files can be found in `}<inlineCode parentName=\"p\">{`tests/stubs`}</inlineCode>{` folder.\nThis is an example of stub file generated for `}<inlineCode parentName=\"p\">{`c-example/lib/dependent_functions.c`}</inlineCode>{` from the `}<a parentName=\"p\" {...{\n        \"href\": \"https://rnd-gitlab-msc.huawei.com/unittestbot/SampleSolutions/-/tree/master/cpp/c-example\"\n      }}>{`example project`}</a>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`// 1624618650000000000\n// Please, do not change the line above\n\n/*\n * This file is automatically generated by UnitTestBot. For further information see http://utbot.inhuawei.com\n * Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.\n */\n\n#ifdef KLEE_MODE\nextern void klee_make_symbolic(void *addr, unsigned long long nbytes, const char *name);\n#endif\n#include \"dependent_functions_stub.h\"\n\n#define NULL ((void*)0)\n\nint double_max_symbolic;\nint double_max(int a, int b) {\n    static int firstTimeCall = 1;\n    #ifdef KLEE_MODE\n        if (firstTimeCall == 1) {\n            firstTimeCall = 0;\n            klee_make_symbolic(&double_max_symbolic, sizeof(double_max_symbolic), \"double_max_symbolic\");\n        }\n    #endif\n    return double_max_symbolic;\n}\n\n`}</code></pre>\n    <p>{`The first line contains timestamp of stub file creation. It is required for synchronization with the source code, so, please, do not modify this line:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`// 1619438023000000000\n`}</code></pre>\n    <p>{`Then, if a `}<inlineCode parentName=\"p\">{`KLEE_MODE`}</inlineCode>{` macro is passed during preprocessing, we add a KLEE declaration to allow us to use symbolic return value. `}<inlineCode parentName=\"p\">{`KLEE_MODE`}</inlineCode>{` serves for both test generation and test running purposes.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`#ifdef KLEE_MODE\nextern void klee_make_symbolic(void *addr, unsigned long long nbytes, const char *name);\n#endif\n`}</code></pre>\n    <p>{`This variable stores return value of the stub function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`int double_max_symbolic;\n`}</code></pre>\n    <p>{`Stub function signature is always the same as the signature of the source function. If it's not (for example, if the function was modified), then UTBot will synchronize them by rewriting stub function with the new one:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`int double_max(int a, int b)\n`}</code></pre>\n    <p>{`If UTBot uses stubs, then `}<inlineCode parentName=\"p\">{`KLEE_MODE`}</inlineCode>{` is defined, and the return value is made symbolic. This way KLEE can decide what values to return to satisfy the execution paths:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`static int firstTimeCall = 1;\n#ifdef KLEE_MODE\n    if (firstTimeCall == 1) {\n        firstTimeCall = 0;\n        klee_make_symbolic(&double_max_symbolic, sizeof(double_max_symbolic), \"double_max_symbolic\");\n    }\n#endif\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"stub-headers\"\n    }}>{`Stub headers`}</h3>\n    <p>{`For each stub, a header is generated. It contains definitions of types and structures used in function headers, allowing stubs to be compilable.\nStub headers may contain definitions fetched from system headers and may look obscure, but usually you will not modify them.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`üìù`}<strong parentName=\"p\">{`Note`}</strong></p>\n      <p parentName=\"blockquote\">{`You can change the stub function body however you want. UTBot saves custom code inside the function while synchronizing. However, if the source function signature changes, then stub function will be completely rewritten.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"tests-with-stubs\"\n    }}>{`Tests with stubs`}</h3>\n    <p>{`For the tests that use stubs, the return values are generated in a such way that the code coverage is maximized.\nFor example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`extern \"C\" char pointerToPointer_symbolic;\n\nTEST(regression, calc_two_numbers_f_test_1)\n{\n    // Initialize symbolic stubs\n    pointerToPointer_symbolic = '\\\\x10';\n\n    // Construct input\n    char a = 'c';\n    char b = 'p';\n\n    // Expected output\n    int expected = 2;\n\n    // Trigger the function\n    int actual = calc_two_numbers_f(a, b);\n\n    // Check results\n    EXPECT_EQ(expected, actual);\n}\n\nTEST(regression, calc_two_numbers_f_test_2)\n{\n    // Initialize symbolic stubs\n    pointerToPointer_symbolic = 'b';\n\n    // Construct input\n    char a = 'c';\n    char b = 'b';\n\n    // Expected output\n    int expected = 1;\n\n    // Trigger the function\n    int actual = calc_two_numbers_f(a, b);\n\n    // Check results\n    EXPECT_EQ(expected, actual);\n}\n`}</code></pre>\n    <p>{`Here `}<inlineCode parentName=\"p\">{`pointerToPointer_symbolic`}</inlineCode>{` stores return value for `}<inlineCode parentName=\"p\">{`pointerToPointer`}</inlineCode>{` stub function.`}</p>\n    <h3 {...{\n      \"id\": \"modifying-stubs\"\n    }}>{`Modifying stubs`}</h3>\n    <p>{`As it was noted, it is easy to rewrite UTBot stubs into anything you want them to be.\nYou should modify only function bodies and not touch header include, or `}<inlineCode parentName=\"p\">{`KLEE_MODE`}</inlineCode>{` ifdefs.\nConsider the simplest example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`// 1624618650000000000\n// Please, do not change the line above\n\n/*\n * This file is automatically generated by UnitTestBot. For further information see http://utbot.inhuawei.com\n * Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.\n */\n\n#ifdef KLEE_MODE\nextern void klee_make_symbolic(void *addr, unsigned long long nbytes, const char *name);\n#endif\n#include \"dependent_functions_stub.h\"\n\n#define NULL ((void*)0)\n\nint double_max_symbolic;\nint double_max(int a, int b) {\n    return a;\n}\n`}</code></pre>\n    <p>{`In such a case, UTBot will generate tests for functions from other CMake modules implying that `}<inlineCode parentName=\"p\">{`double_max(int a, int b) = a`}</inlineCode>{`.`}</p>\n    <p>{`However, you can also use symbolic variable power when modifying stubs. Suppose that you want your function not to return any value, but perform some checks on the arguments prior to that. Also, there may be a special case in that function that is highly important to be reflected in the stub. In that case, you can insert those checks in the stub, and, if they succeed, return a symbolic value:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-cpp\"\n      }}>{`// 1624618650000000000\n// Please, do not change the line above\n\n/*\n * This file is automatically generated by UnitTestBot. For further information see http://utbot.inhuawei.com\n * Copyright (c) Huawei Technologies Co., Ltd. 2021-2021. All rights reserved.\n */\n\n#ifdef KLEE_MODE\nextern void klee_make_symbolic(void *addr, unsigned long long nbytes, const char *name);\n#endif\n#include \"dependent_functions_stub.h\"\n\n#define NULL ((void*)0)\n\nint double_max_symbolic;\nint double_max(int a, int b) {\n    if (a == 100 && a > b) {\n        return 100;\n    }\n    static int firstTimeCall = 1;\n    #ifdef KLEE_MODE\n        if (firstTimeCall == 1) {\n            firstTimeCall = 0;\n            klee_make_symbolic(&double_max_symbolic, sizeof(double_max_symbolic), \"double_max_symbolic\");\n        }\n    #endif\n    return double_max_symbolic;\n}\n`}</code></pre>\n    <p>{`By this change, `}<inlineCode parentName=\"p\">{`double_max(a, b)`}</inlineCode>{` will preserve its behaviour if a certain condition holds. This principle can be used to achieve the similarity of the stub and the original code while leaving out big parts of code.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}