"use strict";(self.webpackChunkunittestbot_web=self.webpackChunkunittestbot_web||[]).push([[7690],{41147:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return l},default:function(){return m}});var n=a(87462),o=a(63366),r=(a(15007),a(64983)),s=a(23017),i=(a(8156),["components"]),l={};void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!Object.prototype.hasOwnProperty.call(l,"__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/general/Home.md"}});var c={_frontmatter:l},u=s.Z;function m(e){var t=e.components,a=(0,o.Z)(e,i);return(0,r.kt)(u,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("h2",{id:"what-is-unittestbot"},"What is UnitTestBot?"),(0,r.kt)("p",null,"UnitTestBot (aka UTBot) tool provides engineers with a simple 1-mouse-click way to automatically generate unit tests and visualize coverage for projects written in C and C++ Programming Languages. It is an IDE extension (the client) paired with server application."),(0,r.kt)("p",null,"The tool uses ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Symbolic_execution"},"symbolic execution")," for test cases generation. UTBot uses KLEE Symbolic Virtual Machine enchanced with a new advanced bidirectional symbolic execution algorithm developed by Research Group from Saint Petersburg State University. Tests are generated in form of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/google/googletest"},"Google Test Framework"),"."),(0,r.kt)("h2",{id:"tests-generation-regression-suite"},"Tests Generation: Regression Suite"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"UnitTestBot")," generates test cases by code, trying to cover maximum statements and execution paths.\nWe treat source code as ",(0,r.kt)("em",{parentName:"p"},"source of truth")," assuming that behavior is correct (corresponds to initial user demand).\nGenerated tests are placed in the so-called ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"regression suite")),". Thus, we ",(0,r.kt)("em",{parentName:"p"},"fixate")," current behavior by test cases."),(0,r.kt)("p",null,"What is the purpose? You obtain ",(0,r.kt)("strong",{parentName:"p"},"full control")," of future code changes. Any code change now ",(0,r.kt)("strong",{parentName:"p"},"can't break behavior silently"),".\nIf developer changes the code, then some tests will fall on CI. Then, ther are two possible scenarios:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Initial behavior was ",(0,r.kt)("span",{style:{color:"green"}},(0,r.kt)("b",null,"correct"))," but developer ",(0,r.kt)("i",null,"broke")," it. And, as a result, generated test helped to find a bug."),(0,r.kt)("li",{parentName:"ul"},"Initial behavior was ",(0,r.kt)("span",{style:{color:"red"}},(0,r.kt)("b",null,"incorrect"))," and developer ",(0,r.kt)("i",null,"fixed")," it. Then, test must be manually updated to fixate\nnew behavior.")),(0,r.kt)("p",null,"UTBot provides dramatic code quality improvement in the long term: after tests are generated no change can break behavior without an alarm."),(0,r.kt)("h2",{id:"test-generation-errors-detection"},"Test Generation: Errors Detection"),(0,r.kt)("p",null,"UnitTestBot is not only able to fixate the behavior in an existing code, but it also helps to find real bugs in your project. Some code fragments might be invalid, while developers don't know about it. For example, buffer overflows, assertion failures, segmentation faults, and so on. If UTBot finds an execution\npath leading to such a situation, it creates a special test case that is added to the so-called ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"error suite")),". "),(0,r.kt)("p",null,"While all tests from ",(0,r.kt)("em",{parentName:"p"},"regression suite")," are ",(0,r.kt)("em",{parentName:"p"},"green")," right after generation, tests from ",(0,r.kt)("em",{parentName:"p"},"error suite")," are ",(0,r.kt)("em",{parentName:"p"},"red")," (they fail if you run them).\nSuch tests generated by UnitTestBot are a convenient way to discover critical problems as soon as possible. After developer fixes a bug, tests can be rerun to verify the problem is gone."),(0,r.kt)("h2",{id:"code-coverage"},"Code Coverage"),(0,r.kt)("p",null,"UTBot tries to generate test cases that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"maximize ",(0,r.kt)("a",{href:"https://en.wikipedia.org/wiki/Code_coverage"},"code coverage")," (by statements and branches);"),(0,r.kt)("li",{parentName:"ul"},"minimize number of tests, i.e. if you drop any test case from generated suite, your code coverage decreases.")),(0,r.kt)("p",null,"Of course, in an ideal world we would like to test ",(0,r.kt)("strong",{parentName:"p"},"every")," execution path of the program (so-called ",(0,r.kt)("em",{parentName:"p"},"path coverage"),"), but the number of such\npaths is often infinite due to loops and recursion. UnitTestBot aims to maximize other types of coverages: ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"statement coverage")),"\nand ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"branch coverage")),", most commonly used as metrics for coverage quality assessment tools."))}m&&m===Object(m)&&Object.isExtensible(m)&&!Object.prototype.hasOwnProperty.call(m,"__filemeta")&&Object.defineProperty(m,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/general/Home.md"}}),m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-general-home-md-c632dd3122758728a118.js.map