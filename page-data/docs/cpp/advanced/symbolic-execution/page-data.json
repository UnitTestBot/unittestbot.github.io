{"componentChunkName":"component---src-templates-docs-page-jsx","path":"/docs/cpp/advanced/symbolic-execution","result":{"data":{"markdownRemark":{"html":"<p>UTBot runs KLEE by fork() + exec() method and controls symbolic execution via waitpid(). UTBot uses Z3 version 4.8.7 as\nSMT-solver for KLEE. Symbolic execution of each function under test issues a separate KLEE run, which symbolically\nexecutes the function wrapper generated by UTBot. UTBot gives KLEE a configurable amount of time to symbolically execute\ngiven bitcode, and, when it ends, sends KLEE a SIGINT signal, which is correctly handled by KLEE in many cases — the\nengine saves explored paths and finishes the execution. However, there are scenarios where KLEE does not handle SIGINTs\ncorrectly due to missing handlers in some parts of its code; so UTBot waits a specified amount of time and then sends\nstronger signals: SIGSTOP, and, eventually, SIGKILL. UTBot KLEE configuration. UTBot runs KLEE with the following\nparameters:</p>\n<pre><code class=\"language-shell\">klee --entry-point=klee_entry__max\n--libc=klee --posix-runtime --fp-runtime\n--only-output-states-covering-new \n--allocate-determ --external-calls=all \n--timer-interval=1s --bcov-check-interval=5s\n--disable-verify --output-dir=klee-out-dir\nbitcode.bc --sym-stdin 64\n</code></pre>\n<p>Let us explain every KLEE command line option passed by UTBot in detail:</p>\n<ul>\n<li>KLEE is given a bitcode representation of a project target, which may contain many functions, so KLEE understands\nwhere to begin symbolic execution by an entry-point option. To improve symbolic execution possibilities, KLEE needs to\nbe supplied with standard C library, i.e. libc, compiled into LLVM IR. There is a choice one can make between using\nKLEE libc — a small set of libc functions shipped with KLEE itself,\nor <a href=\"https://github.com/klee/klee-uclibc\">klee-uclibc</a>, a more complete package, which can be linked with KLEE and used\nduring symbolic execution. Again (as with POSIX runtime), this KLEE libc or klee-uclibc library can be treated as\nstubs that used by KLEE instead of real libc. UTBot uses KLEE libc. Despite that a wider set of functions is\nimplemented in klee-uclibc, using it forces KLEE to analyse additional several thousands of LLVM instructions prior to\nanalysing actual code of UTBot wrapper, consequently, slowing down UTBot test generation. It is understood that\ncoverage may be lost using –libc=klee instead of –libc=uclibc, so it is planned to make the libc selection\nconfigurable;</li>\n<li>UTBot uses KLEE POSIX runtime and self-developed floatingpoint runtime library to allow symbolic execution of programs\noperating with file descriptors and floating-point values;</li>\n<li>–only-output-states-covering-new option is used to not generate tests executing the same path in user functions;</li>\n<li>UTBot allows all external calls to discard minimal number of branches. External call is a possibility of KLEE to\nexecute a function not implemented in LLVM IR. For that, function arguments are concretized, which potentially leads\nto a coverage loss, but other options of handling external function calls, like killing an execution branch, are even\nworse in terms of achieving maximal coverage;</li>\n<li>timer-interval and self-invented bcov-check-interval are used to stop symbolic execution of branches not promising to\nincrease coverage;</li>\n<li>UTBot allows using 64 bytes of symbolic stdin;</li>\n<li>UTBot uses –disable-verify as its linking procedure (Section 3.3) passes only correct bitcode to KLEE.</li>\n</ul>","frontmatter":{"path":"/docs/cpp/advanced/symbolic-execution"}}},"pageContext":{}},"staticQueryHashes":["1550867996","2819311301"]}