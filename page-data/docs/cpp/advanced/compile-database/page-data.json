{"componentChunkName":"component---src-templates-docs-page-jsx","path":"/docs/cpp/advanced/compile-database","result":{"data":{"markdownRemark":{"html":"<h1>Compile database</h1>\n<p>When C/C++ project is opened in VS Code with UTBot plugin enabled, the plugin tries to obtain information about the\nproject structure. UTBot needs this information to create sources’ ASTs with clang-tooling and to rebuild the project in\nLLVM IR. LLVM has a special format, designed to store project information (i.e. compilation database) —\n<a href=\"https://clang.llvm.org/docs/LibTooling.html\">compile_commands.json</a>. There are various ways to obtain\ncompile_commands.json:</p>\n<ul>\n<li>If a project is built with CMake, one can pass CMAKE_EXPORT_COMPILE_COMMANDS=ON option to it;</li>\n<li>One can run the <a href=\"https://github.com/rizsotto/Bear\">Bear tool</a>. Bear is able to create compile_commands.json by\nanalysing Makefile commands, hence, Bear can be used if make command can be applied to a project.</li>\n</ul>\n<p>Unfortunately, compile_commands.json only contains information about compilation of individual source files. That is not\nsufficient to determine function behaviour. Consider a function 𝑓, which calls a function 𝑔 in its body, while 𝑔 is\nspecified by an external symbol. The definition of 𝑔 can be provided to 𝑓 if an artifact containing 𝑓 is linked with\nthe artifact containing 𝑔. If there are multiple functions 𝑔 in the project, it is impossible to determine, which\nfunction is used by 𝑓, with only compile commands. To find a solution, a new format was invented — link_commands.json.\nIt shares the way of representing data with compile_commands.json, but holds information from project link commands. A\nlink_commands.json example can be viewed bellow. With this information, it is easy to solve the mentioned problem — one\nhas to look up for a pair of artifacts containing 𝑓 and 𝑔, which are linked together while the project builds. UTBot\nneeded to be able to retrieve both compile and link information from a project. The vast majority of C/C++ projects are\nbuilt with either CMake or Makefile build systems. UTBot supports both of these, using the following approach:</p>\n<pre><code class=\"language-json\">[\n  {\n    \"command\": \"/usr/bin/ar qc liblib.a CMakeFiles/lib.dir/file3.c.o\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/lib.dir/file3.c.o\"\n    ]\n  },\n  {\n    \"command\": \"clang -fuse-ld=gold CMakeFiles/exe2.dir/file4.c.o -o exe2  liblib.a\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/exe2.dir/file4.c.o\",\n      \"c-example/build/liblib.a\"\n    ]\n  },\n  {\n    \"command\": \"/usr/bin/ar qc libhelper.a CMakeFiles/helper.dir/file1.c.o\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/helper.dir/file1.c.o\"\n    ]\n  },\n  {\n    \"command\": \"clang -fuse-ld=gold CMakeFiles/exe1.dir/file2.c.o -o exe1 libhelper.a liblib.a\",\n    \"directory\": \"c-example/build\",\n    \"files\": [\n      \"c-example/build/CMakeFiles/exe1.dir/file2.c.o\",\n      \"c-example/build/libhelper.a\",\n      \"c-example/build/liblib.a\"\n    ]\n  }\n]\n</code></pre>\n<ol>\n<li>If a given project is a CMake project, UTBot prompts user to invoke a cmake command on it, generating Makefiles (or\noffers to automatically do it by itself). From now on, all projects can be treated as projects which are built with\nthe use of Makefiles;</li>\n<li>UTBot applies Bear to project Makefiles. Bear is able to create compile_commands.json, and it was patched, so it is\nable to construct link_commands.json as well.</li>\n</ol>\n<p>The approach scheme can be viewed on scheme bellow, with algorithm steps highlighted with blue arrows.</p>\n<p><img src=\"https://github.com/UnitTestBot/unittestbot.github.io/raw/source/resources/images/jsons.png\" alt=\"jsons\"></p>","frontmatter":{"path":"/docs/cpp/advanced/compile-database"}}},"pageContext":{}},"staticQueryHashes":["1550867996","2819311301"]}